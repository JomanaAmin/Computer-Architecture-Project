`timescale 1ns / 1ps

module SingleCycleCPU(
    input wire clk,
    input wire reset
);

    // PC
    wire [63:0] PC, PC_next, PC_plus4;
  wire PCSrc; //which is PCScr, (branch AND zero flag from alu)
  wire [63:0] BranchTarget; //which is PC+offset (immediate value)
    reg PCWrite = 1;

    PC_Unit pc_unit(
        .clk(clk),
        .reset(reset),
        .PCWrite(PCWrite),
      .BranchTaken(PCSrc),
        .BranchTarget(BranchTarget),
        .PC(PC)
    );

    // Instruction Memory
  wire [31:0] currInstruction;
    InstructionMemory InstrucMem(
        .address(PC),
        .instruction(currInstruction)
    );

    // Instruction fields R type
    wire [6:0] opcode = currInstruction[6:0];
    wire [4:0] rd     = currInstruction[11:7];
    wire [2:0] func3  = currInstruction[14:12];
    wire [4:0] rs1    = currInstruction[19:15];
    wire [4:0] rs2    = currInstruction[24:20];
    wire [6:0] func7  = currInstruction[31:25];
//   wire [31:0] immediate = [:];

    // Control Signals based on instruction code
    wire Branch, MemRead, MemtoReg, MemWrite, ALUSrc, RegWrite;
    wire [1:0] ALUOp;
    ControlUnit ctrl(
        .opcode(opcode),
        .Branch(Branch),
        .MemRead(MemRead),
        .MemtoReg(MemtoReg),
        .MemWrite(MemWrite),
        .ALUSrc(ALUSrc),
        .RegWrite(RegWrite),
        .ALUOp(ALUOp)
    );

    // Registers
  wire [63:0] readData1, readData2;
  reg [63:0] writeData;

    register regfile(
        .clk(clk),
        .we(RegWrite),
        .rs1(rs1),
        .rs2(rs2),
        .rd(rd),
        .wd(writeData),
        .rd1(readData1),
        .rd2(readData2)
    );

    // Immediate
  wire [63:0] immediate;
    Immediate ImmGen(
        .instr(currInstruction),
        .imm(immediate)
    ); // this module returns the extended immediate value

    // ALU Control
    wire [3:0] ALUCtl;
    ALUControl alu_ctrl(
        .ALUOp(ALUOp),
        .func3(func3),
        .func7(func7),
        .ALUCtl(ALUCtl)
    );

    // ALU input mux
  wire [63:0] ALU_2nd_input = (ALUSrc) ? immediate : readData2;
  //if ALU Src is 1, use immediate as input for alu, otherwise use data read from rs2 (readData2)
  
    wire [63:0] ALU_result;
    wire Zero; //zero flag
  ALU alu( //this will perform the operation based on the inputs and alu control signal
    .A(readData1),
        .B(ALU_2nd_input),
        .ALUCtl(ALUCtl),
        .ALUOut(ALU_result),
        .Zero(Zero)
    );

    // Branch Logic
    assign PCSrc = Branch & Zero; //to check whether pc will be updated by offset or normal +4
    assign BranchTarget = PC + immediate*2; //branch that we will take in case PCSrc is 1. I think we should multiply immediate by 2 (shift left 1)

    // Data Memory
  wire [63:0] memReadData; //data read from memory if load
    DataMemory DataMem(
        .clk(clk),
      .address(ALU_result[31:0]), //in case of ld/sd we will use alu output (offset+base)
      .writeData(readData2), //in case of store, we will use also data read from rs2 to store it in memory 
      .memWrite(MemWrite), //signal to store to memory from control unit
      .memRead(MemRead), //signal to read from memory in case of load
      .readData(memReadData) //data fetched/read from memory in case of load
    );//this module will check if memwrite is 1 (store), if not it will check if memread is 1 (load), if memread is 1, it will read from memory and transfer data to memReadData, if it is 0 it will store 0 in memReadData

    // Write-back mux
  // will check if MemToReg is 1(will only be true in case of Load), if so, will write back memReadData, otherwise writes back alu result 
    always @(*) begin
        if (MemtoReg)
            writeData = memReadData;
        else
            writeData = ALU_result;
    end

endmodule
